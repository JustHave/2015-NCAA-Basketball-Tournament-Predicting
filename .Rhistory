my.pred <- predict(my.cv, s = "lambda.min", newx=x, type = "class")
sum(my.pred==y)
sum(my.pred==y)/length(y)
my.pred <- predict(my.cv, s = "lambda.1se", newx=x, type = "class")
sum(my.pred==y)/length(y)
my.pred <- predict(my.cv, s = "lambda.min", newx=x, type = "class")
sum(my.pred==y)/length(y)
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=1, nfolds=50, type.measure = "class")
summary(my.cv)
my.cv
coef(my.cv, s = "lambda.min")
# Clear memory and load packages
rm(list=ls())
library(stats)
library(glmnet)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# Clear memory and load packages
rm(list=ls())
library(stats)
library(glmnet)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
y <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- y
# Clear memory and load packages
rm(list=ls())
library(stats)
library(glmnet)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
y <- data.diff[,1]
y <- sapply(y, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
y <- as.factor(y)
data.tr <- data.diff
data.tr[,1] <- y
x <- data.matrix(data.tr[,-1])
y <- factor(data.tr[,1])
model.log = cv.glmnet(x, y, family = "binomial", , alpha=1, nfolds=50, type.measure = "class")
plot(model.log)
coef(my.cv, s = "lambda.min")
coefmodel.log, s = "lambda.min")
coef(model.log, s = "lambda.min")
,8,9,
var <- c(1,3,4,8,9,11,12,14:21) + 1
var
var <- c(1,3,4,8,9,11,12,14:21)
x <- x[,var]
# Fit ridge logistic model, do cross validation
model.log = cv.glmnet(x, y, family = "binomial", , alpha=1, nfolds=50, type.measure = "class")
my.pred <- predict(my.cv, s = "lambda.min", newx=x, type = "class")
sum(my.pred==y)/length(y)
my.pred <- predict(model.log, s = "lambda.min", newx=x, type = "class")
sum(my.pred==y)/length(y)
my.pred
View(data.tr)
coef(model.log, s = "lambda.min")
plot(data.tr[,19], data.tr[,21])
plot(data.tr[,19], data.tr[,21], color=data.tr[,1])
plot(data.tr[,19], data.tr[,21], colour=data.tr[,1])
plot(data.tr[,19], data.tr[,21], colour=as.numeric(data.tr[,1]))
as.numeric(data.tr[,1])
?plot
plot(data.tr[,19], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,20], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,2], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,3], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,4], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,5], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,6], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,7], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,8], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,9], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,10], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,11], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,12], data.tr[,21], col=as.numeric(data.tr[,1]))
plot(data.tr[,13], data.tr[,21], col=as.numeric(data.tr[,1]))
model.log
x.new <- data.matrix(data.tourney[,-1])
x.new
View(x.new)
x.new <- x.new[,var]
my.pred <- predict(model.log, s = "lambda.min", newx=x.new, type = "class")
my.pred
y.new <- data.tourney[,1]
y.new <- data.tourney[,1]
y.new <- sapply(y.new, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
y.new <- as.factor(y.new)
y.new == my.pred
sum(y.new == my.pred)
sum(y.new == my.pred)/length(y.new)
# install.packages('e1071',dependencies=TRUE)
# Clearing memory, loading packages
rm(list=ls())
library(e1071)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# -------------------- Fitting The Model -------------------- #
# Fitting the model
model.svm  <- svm(score.diff~., data = data.tr)
summary(model.svm)
# Checking its accuracy
pred <- predict(model.svm, data.tr)
tab <- table(pred=pred, true=data.tr[,1])
classAgreement(tab)
tuned <- tune.svm(score.diff~., data = data.tr)
# Error estimation of svm using 10-fold cross validation: 0.2394209
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tourney[,1] <- myY
pred <- predict(model.svm, data.tourney)
View(data.tourney)
pred <- predict(model.svm, data.tourney)
View(data.diff)
View(data.tr)
# Cleaning the response
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.tourney
data.tr[,1] <- myY
View(data.tr)
)
pred <- predict(model.svm, data.tr)
na.omit(data.tr)
data.tr <- na.omit(data.tr)
pred <- predict(model.svm, data.tr)
# install.packages('e1071',dependencies=TRUE)
# Clearing memory, loading packages
rm(list=ls())
library(e1071)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# install.packages('e1071',dependencies=TRUE)
# Clearing memory, loading packages
rm(list=ls())
library(e1071)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# Cleaning the response
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.test <- data.tourney
data.test[,1] <- myY
View(data.tr)
View(data.test)
model.svm  <- svm(score.diff~., data = data.tr)
summary(model.svm)
# Checking its accuracy
pred <- predict(model.svm, data.tr)
tab <- table(pred=pred, true=data.tr[,1])
classAgreement(tab)
tab
tuned <- tune.svm(score.diff~., data = data.tr)
tuned
model.svm  <- svm(score.diff~., data = data.test)
View(data.tourney)
View(data.tr)
case.complete
complete.cases(data.test)
col.fac <- c(1,2,4,6)
data.test[,col.fac] <- factor(data.test[,col.fac])
data.test[,col.fac] <- as.factor(data.test[,col.fac])
])
data.test[,1] <- factor(data.test[,1])
model.svm  <- svm(score.diff~., data = data.tr)
model.svm  <- svm(score.diff~., data = data.test)
data.test[,1] <- factor(data.test[,1])
model.svm  <- svm(score.diff~., data = data.test)
data.test[,-col.fac] <- data.matrix(data.test[,-col.fac])
model.svm  <- svm(score.diff~., data = data.test)
data.test[,1] <- factor(data.test[,1])
data.test[,2] <- factor(data.test[,2])
data.test[,4] <- factor(data.test[,4])
data.test[,6] <- factor(data.test[,6])
model.svm  <- svm(score.diff~., data = data.test)
View(data.test)
# Fitting the model
model.svm  <- svm(score.diff~., data = data.tr)
summary(model.svm)
# Checking its accuracy
pred <- predict(model.svm, data.tr)
tab <- table(pred=pred, true=data.tr[,1])
classAgreement(tab)
tuned <- tune.svm(score.diff~., data = data.tr)
pred <- predict(model.svm, data.tr)
pred
data.tr[1:67,] <- data.test
pred <- predict(model.svm, data.tr)
pred <- predict(model.svm, data.tr[1:67,])
tab <- table(pred=pred, true=data.tourney[1:67,1])
classAgreement(tab)
pred
data.tourney[1:67,1]
tab <- table(pred=pred, true=data.test[,1])
classAgreement(tab)
tab
46/67
data.tr[1:67,] <- data.test
pred <- predict(model.svm, data.tr[1:67,])
tab <- table(pred=pred, true=data.test[,1])
classAgreement(tab)
# Clear memory and load packages
rm(list=ls())
library(stats)
library(glmnet)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
y <- data.diff[,1]
y <- sapply(y, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
y <- as.factor(y)
data.tr <- data.diff
data.tr[,1] <- y
# Arrange the data
x <- data.matrix(data.tr[,-1])
y <- factor(data.tr[,1])
# Fit lasso logistic model, do cross validation
model.log = cv.glmnet(x, y, family = "binomial", , alpha=1, nfolds=50, type.measure = "class")
plot(model.log)
coef(model.log, s = "lambda.min")
var <- c(1,3,4,8,9,11,12,14:21)
x <- x[,var]
# Fit ridge logistic model, do cross validation
model.log = cv.glmnet(x, y, family = "binomial", , alpha=1, nfolds=50, type.measure = "class")
# Check the accuracy
my.pred <- predict(model.log, s = "lambda.min", newx=x, type = "class")
sum(my.pred==y)/length(y)
x.new <- data.matrix(data.tourney[,-1])
x.new <- x.new[,var]
y.new <- data.tourney[,1]
y.new <- sapply(y.new, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
y.new <- as.factor(y.new)
my.pred <- predict(model.log, s = "lambda.min", newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = "lambda.1se", newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 0.01, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 0.001, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 0.0001, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 0.00001, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 0.000001, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 1 newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = 1, newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
my.pred <- predict(model.log, s = "lambda.1se", newx=x.new, type = "class")
sum(y.new == my.pred)/length(y.new)
# install.packages('e1071',dependencies=TRUE)
# Clearing memory, loading packages
rm(list=ls())
library(e1071)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# Cleaning the response
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.test <- data.tourney
data.test[,1] <- myY
model.svm  <- svm(score.diff~., data = data.tr)
data.tr[1:67,] <- data.test
pred <- predict(model.svm, data.tr[1:67,])
tab <- table(pred=pred, true=data.test[,1])
classAgreement(tab)
# install.packages('rpart',dependencies=TRUE)
# install.packages('randomForest',dependencies=TRUE)
# install.packages('party')
# Clearing memory, loading packages
rm(list=ls())
library(rpart)
library(e1071)
library(party)
library(randomForest)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# Cleaning the response
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.test <- data.tourney
data.test[,1] <- myY
model.tree <- rpart(score.diff~., data = data.tr, method="class")
printcp(model.tree) # display the results
model.tree <- rpart(score.diff~., data = data.tr)
printcp(model.tree) # display the results
# install.packages('rpart',dependencies=TRUE)
# install.packages('randomForest',dependencies=TRUE)
# install.packages('party')
# Clearing memory, loading packages
rm(list=ls())
library(e1071)
library(party)
library(randomForest)
# Reading the data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
# Cleaning the data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
# Cleaning the response
myY <- data.diff[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.tr <- data.diff
data.tr[,1] <- myY
# Cleaning the response
myY <- data.tourney[,1]
myY <- sapply(myY, function(y){
if(y>0) return("WIN")
else return("LOSE")
})
myY <- as.factor(myY)
data.test <- data.tourney
data.test[,1] <- myY
model.tree <- cforest(score.diff~., data = data.tr, controls=cforest_unbiased(ntree=300, mtry=3))
pred <- predict(model.tree, data.test)
data.tr[1:67,] <- data.test
pred <- predict(model.tree, data.tr[1:67,])
pred <- predict(model.tree, newdata=data.tr[1:67,])
pred <- predict(model.tree, newdata=data.test)
data.tr[1:67,] <- data.test
pred <- predict(model.tree, newdata=data.tr[1:67,])
tab <- table(pred=pred, true=data.test[,1])
classAgreement(tab)
tab
