newY <- as.numeric(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred <- sapply(newPred, function(y){return(y>0.5)})
newPred <- as.numeric(newPred)
sum(newY==newPred) / length(newY)
rm(list=ls())           # Clear Memory
# Read Data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2013.R")
data.tourney <- data.tourney[,-c(1,2)]
# -------------------- Fitting Linear Model -------------------- #
myModel <- lm(score.diff ~. , data=data.diff)
summary(myModel)
plot(data.diff[,1], predict(myModel))
newPred <- predict(myModel, newdata = data.tourney[,-1], type="response")
plot(data.tourney[,1], newPred)
accuracy <- as.logical(data.tourney[,1] * newPred > 0)
sum(accuracy) / length(accuracy)
myY <- data.diff[,1]
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
data.diff[,1] <- myY
data.diff[,1] <- factor(data.diff[,1])
myModel <- glm(score.diff ~. , data=data.diff, family=binomial)
summary(myModel)
myPred <- predict(myModel)
myPred <- sapply(myPred, function(y){return(y>0.5)})
myPred <- as.numeric(myPred)
sum(myY==myPred) / length(myY)
newY <- data.tourney[,1]
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred <- sapply(newPred, function(y){return(y>0.5)})
newPred <- as.numeric(newPred)
sum(newY==newPred) / length(newY)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2015.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2012.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
fit = glmnet(x=myX, y=myY, alpha = 1)
par(mfrow=c(1,1))
plot(fit, xvar = "lambda", label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "mse", nfolds = 20)
plot(cvfit, xvar = "lambda", label = TRUE)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
plot(newY, newPred)
accuracy <- newY * newPred > 0
sum(accuracy) / length(accuracy)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2015.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2014.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
fit = glmnet(x=myX, y=myY, alpha = 1)
par(mfrow=c(1,1))
plot(fit, xvar = "lambda", label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "mse", nfolds = 20)
plot(cvfit, xvar = "lambda", label = TRUE)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
plot(newY, newPred)
accuracy <- newY * newPred > 0
sum(accuracy) / length(accuracy)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2014.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
fit = glmnet(x=myX, y=myY, alpha = 1)
par(mfrow=c(1,1))
plot(fit, xvar = "lambda", label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "mse", nfolds = 20)
plot(cvfit, xvar = "lambda", label = TRUE)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
plot(newY, newPred)
accuracy <- newY * newPred > 0
sum(accuracy) / length(accuracy)
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
fit = glmnet(x=myX, y=myY, family = "binomial")
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2013.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
# -------------------- Fitting Linear Model -------------------- #
fit = glmnet(x=myX, y=myY, alpha = 1)
par(mfrow=c(1,1))
plot(fit, xvar = "lambda", label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "mse", nfolds = 20)
plot(cvfit, xvar = "lambda", label = TRUE)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
plot(newY, newPred)
accuracy <- newY * newPred > 0
sum(accuracy) / length(accuracy)
# -------------------- Fitting Logistic Model -------------------- #
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
fit = glmnet(x=myX, y=myY, family = "binomial")
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2014.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2014.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
# -------------------- Fitting Linear Model -------------------- #
fit = glmnet(x=myX, y=myY, alpha = 1)
par(mfrow=c(1,1))
plot(fit, xvar = "lambda", label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "mse", nfolds = 20)
plot(cvfit, xvar = "lambda", label = TRUE)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
plot(newY, newPred)
accuracy <- newY * newPred > 0
sum(accuracy) / length(accuracy)
# -------------------- Fitting Logistic Model -------------------- #
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
fit = glmnet(x=myX, y=myY, family = "binomial")
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
myY
sum(newY == newPred) / length(newY)
k <- 0
for(i in myY) {
k <- k+i
}
myY
k <- 0
for(i in newY) {
k <- k+i
}
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2014.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2014.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
myY
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.factor(myY)
myY
fit = glmnet(x=myX, y=myY, family = "binomial")
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.factor(newY)
newY
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
newPred
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred
newPred <- 1/(1+exp(-newPred))
newPred
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
logloss <- 0
for(i in newY) {
logloss <- logloss + (i*log(newPred[i]))
logloss <- logloss + ((1-i)*log(1-newPred[i]))
}
for(i in newY) {
i <- as.numeric(i)
logloss <- logloss + (i*log(newPred[i]))
logloss <- logloss + ((1-i)*log(1-newPred[i]))
}
newY
for(i in newY) {
if(i) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
for(i in newY) {
if(i=="TRUE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
i=="TRUE"
log(newPred[i])
newPred[i]
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
newPred
length(newY)
newY[i]
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]=="TRUE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
newY[i]=="TRUE"
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]=="FALSE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]=="TRUE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
rm(list=ls())           # Clear Memory
# Read Data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2013.R")
data.tourney <- data.tourney[,-c(1,2)]
myY <- data.diff[,1]
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
data.diff[,1] <- myY
data.diff[,1] <- factor(data.diff[,1])
myModel <- glm(score.diff ~. , data=data.diff, family=binomial)
summary(myModel)
myPred <- predict(myModel)
myPred <- sapply(myPred, function(y){return(y>0.5)})
myPred <- as.numeric(myPred)
sum(myY==myPred) / length(myY)
newY <- data.tourney[,1]
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred <- sapply(newPred, function(y){return(y>0.5)})
newPred <- as.numeric(newPred)
sum(newY==newPred) / length(newY)
newPred
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred
newY
for(i in 1:length(newY)) {
if(newY[i]==1) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]==1) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
sum(newY==newPred) / length(newY)
rm(list=ls())           # Clear Memory
# Read Data
data.diff <- dget("arranged-data/data-diff-2014.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2014.R")
data.tourney <- data.tourney[,-c(1,2)]
myY <- data.diff[,1]
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
data.diff[,1] <- myY
data.diff[,1] <- factor(data.diff[,1])
myModel <- glm(score.diff ~. , data=data.diff, family=binomial)
summary(myModel)
myPred <- predict(myModel)
myPred <- sapply(myPred, function(y){return(y>0.5)})
myPred <- as.numeric(myPred)
sum(myY==myPred) / length(myY)
newY <- data.tourney[,1]
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred <- sapply(newPred, function(y){return(y>0.5)})
newPred <- as.numeric(newPred)
sum(newY==newPred) / length(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]==1) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2013.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.factor(myY)
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.factor(newY)
fit = glmnet(x=myX, y=myY, family = "binomial")
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
newPred <- predict(cvfit, newx = newX, s = "lambda.min")
newPred <- 1/(1+exp(-newPred))
newPred
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]=="TRUE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
rm(list=ls())           # Clear Memory
# Read Data
data.diff <- dget("arranged-data/data-diff-2011.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2011.R")
data.tourney <- data.tourney[,-c(1,2)]
myY <- data.diff[,1]
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.numeric(myY)
data.diff[,1] <- myY
data.diff[,1] <- factor(data.diff[,1])
myModel <- glm(score.diff ~. , data=data.diff, family=binomial)
summary(myModel)
myPred <- predict(myModel)
myPred <- sapply(myPred, function(y){return(y>0.5)})
myPred <- as.numeric(myPred)
sum(myY==myPred) / length(myY)
newY <- data.tourney[,1]
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.numeric(newY)
newPred <- predict(myModel, newdata = data.tourney, type="response")
newPred <- sapply(newPred, function(y){return(y>0.5)})
newPred <- as.numeric(newPred)
sum(newY==newPred) / length(newY)
newPred <- predict(myModel)
newPred
newPred <- predict(myModel, type="response")
newPred
myY
logloss <- 0
for(i in 1:length(myY)) {
if(myY[i]==1) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
newPred <- predict(myModel, type="response")
logloss <- 0
for(i in 1:length(myY)) {
if(myY[i]==1) logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(myY)
sum(myY==myPred) / length(myY)
newPred <- predict(cvfit, newx = newX, s = "lambda.min", type="response")
# Clear Memory, loading package
rm(list=ls())
library(glmnet)
# Read data
data.diff <- dget("arranged-data/data-diff-2013.R")
data.diff <- data.diff[,-c(1,2)]
data.tourney <- dget("arranged-data/data-tourney-diff-2013.R")
data.tourney <- data.tourney[,-c(1,2)]
# Process data
data.diff[,2] <- as.factor(data.diff[,2])
data.diff[,4] <- as.factor(data.diff[,4])
data.diff[,6] <- as.factor(data.diff[,6])
data.tourney[,2] <- as.factor(data.tourney[,2])
data.tourney[,4] <- as.factor(data.tourney[,4])
data.tourney[,6] <- as.factor(data.tourney[,6])
myY <- data.diff[,1]
myX <- data.matrix(data.diff[,-1])
newY <- data.tourney[,1]
newX <- data.matrix(data.tourney[,-1])
myY <- sapply(myY, function(y){return(y>0)})
myY <- as.factor(myY)
newY <- sapply(newY, function(y){return(y>0)})
newY <- as.factor(newY)
fit = glmnet(x=myX, y=myY, family = "binomial")
plot(fit, xvar = "dev", label = TRUE)
cvfit = cv.glmnet(x=myX, y=myY, type.measure = "class", nfolds = 20， family = "binomial")
plot(cvfit, xvar = "lambda", label = TRUE)
cvfit$lambda.min
newPred <- predict(cvfit, newx = newX, type = "class", s = "lambda.min")
sum(newY == newPred) / length(newY)
newPred <- predict(cvfit, newx = newX, s = "lambda.min", type="response")
newPred
logloss <- 0
for(i in 1:length(newY)) {
if(newY[i]=="TRUE") logloss <- logloss + log(newPred[i])
else logloss <- logloss + log(1-newPred[i])
}
logloss <- -logloss/length(newY)
